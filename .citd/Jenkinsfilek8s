pipeline {
    agent {
		kubernetes {
			defaultContainer 'pic18f57q43-cnano-bootloader-melody-xc8-mplabx'
			yamlFile '.citd/cloudprovider.yml'
		}
	}
    parameters {
        string( name: 'NOTIFICATION_EMAIL',
                defaultValue: 'LibraryDevTeam_MCU8@microchip.com',
                description: "Email to send build failure and fixed notifications.")
    }
	
	environment {
		GITHUB_OWNER = 'microchip-pic-avr-solutions'	
		GITHUB_URL ='https://github.com/microchip-pic-avr-solutions/pic18f57q43-cnano-bootloader-melody.git'
		BITBUCKET_URL = 'https://bitbucket.microchip.com/scm/MFML/pic18f57q43-cnano-bootloader-melody.git'
		SEMVER_REGEX = '^(0|[1-9]\\d*)+\\.(0|[1-9]\\d*)+\\.(0|[1-9]\\d*)+$'
		ARTIFACTORY_SERVER = 'https://artifacts.microchip.com:7999/artifactory'
	}	
	options {
		timestamps()
		timeout(time: 30, unit: 'MINUTES')
	}

	stages {
		stage('Checkout') {
			steps {
				checkout scm
			}
		}
		stage('metadata') {
			steps {
				script {
					execute("pip install jsonschema")
					execute("git clone https://bitbucket.microchip.com/scm/citd/metadata-schema.git")
					execute("git clone https://bitbucket.microchip.com/scm/citd/tool-metadata-validator.git")
					execute("cd tool-metadata-validator && python metadata-validator.py -data '../.main-meta/main.json' -schema '../metadata-schema/main-schema.json'")
				}
			}
		}
		stage('Pre-build') {
			steps {
				script {
					MPLABX_PATH= sh (script: 'update-alternatives --list MPLABX_PATH',returnStdout: true).trim()
					COMPILER_PATH= sh (script: 'update-alternatives --list XC8_PATH',returnStdout: true).trim()
					def pDir = "${MPLABX_PATH}/packs"
					def ver = COMPILER_PATH.split('/')[4].substring(1)

					execute("git clone https://bitbucket.microchip.com/scm/citd/tool-mplabx-c-project-generator.git")
					execute("cd tool-mplabx-c-project-generator && node configGenerator.js sp=../ v8=${ver} packs=${pDir}")
				}
			}
		}
		stage('Build') {
			steps {
				script {
					// Install xml2js dependency needed by the tool-mplabx-c-build scripts
					execute("npm i xml2js")
					execute("git clone https://bitbucket.microchip.com/scm/citd/tool-mplabx-c-build.git")
					execute("cd tool-mplabx-c-build && node buildLauncher.js sp=../ rp=./output genMK=true")
					// Store build artifacts for later publishing to Artifactory
				}
			}	
		}
        stage('github-deploy') {
            when {
                tag ''
            }
            steps{
                script{
                    //def topicsAsString = getTopics()
                    def githubObj = getGiHubInfo()
                    def metadata = readJSON file:".main-meta/main.json"					
                    def version = metadata.content.version
					// this if condition allows release only if tag and metadata version match
                    if(version == env.TAG_NAME){
                        download("tool-github-deploy","1.4.0")		
                        execute("chmod +x ./tool-github-deploy/tool-github-deploy/tool-github-deploy.py")  
                        withCredentials([usernamePassword(credentialsId: 'pic-avr-solutions.github.com', usernameVariable: 'USER_NAME', passwordVariable:'PASS' )]) {					
                            execute("python ./tool-github-deploy/tool-github-deploy/tool-github-deploy.py -deploy=true -gpat=${PASS} -dgid=${USER_NAME} -dburl=${env.BITBUCKET_URL} -dgurl=${env.GITHUB_URL} -dtag=${env.TAG_NAME} -dmfd=true -digmc=true -def='.citd, .main-meta'")						
                            execute("python ./tool-github-deploy/tool-github-deploy/tool-github-deploy.py -rpo=true -gpat=${PASS}  -rpn=${githubObj.repoName} -rpp=false -rporg=microchip-pic-avr-solutions")	
                            download("tool-zip-hex-file","1.2.0")
                            execute("pip install xmltodict")
                            execute("cp ./tool-zip-hex-file/zip-hex.py ./")
                            execute("python zip-hex.py --tagName ${env.TAG_NAME}")
                            execute("python ./tool-github-deploy/tool-github-deploy/tool-github-deploy.py -rlo=true -gpat=${PASS}  -rpn=${githubObj.repoName} -rltv=${env.TAG_NAME} -rltt=${env.TAG_NAME} -rlua=./hex-files.zip")	
                        }
                    }
                }
            }			
		}
		
		stage('Portal-Deploy') {
            when {
                // Only deploy if tests passed
                equals expected: 'SUCCESS', actual: currentBuild.currentResult;
                not {
                    changeRequest()
                    }
                // Only deploy valid semantic versioning tags
                tag pattern: "${env.SEMVER_REGEX}", comparator: "REGEXP"
            }
            steps {
                script {
                    def metadata = readJSON file:".main-meta/main.json"
                    def version = metadata.content.version
                    def project = metadata.content.projectName

                    if(version == env.TAG_NAME) {
                        echo "Deploying tag ${env.TAG_NAME} to Discovery portal"
                        def cmdArgs = "'{\"repoOwnerName\":\"$env.GITHUB_OWNER\",\"repoName\":\"$project\",\"tagName\":\"$version\"}'"
                        cmdArgs = cmdArgs.replaceAll("\"","\\\\\"")

                        execute("git clone https://bitbucket.microchip.com/scm/portal/bundles.git")
                        execute("cd bundles && chmod 755 ./portal-client-cli-linux")
                        execute("git clone https://bitbucket.microchip.com/scm/citd/tool-portal-client-launcher.git")
                        execute("cd tool-portal-client-launcher && node portalLauncher.js -app=../bundles/portal-client-cli-linux -cmd=\"uploadGitHub ${cmdArgs}\"")
                        office365ConnectorSend message:"Deployed tag ${env.TAG_NAME} to Discovery portal", webhookUrl: env.TEAMS_WEBHOOK, color: "004DB8"
                    } else {
                        echo "Tag name is not equal to metadata content version."
                        execute("exit 1")
                    }
                }
            }
        }
	}
}
def execute(String cmd) {
	if(isUnix()) {
		sh cmd
	} else {
		bat cmd
	}											  				
}

def download(String toolName,String toolVersion) {
	def repo = "ivy/citd"
	def url = "${env.ARTIFACTORY_SERVER}/${repo}/${toolName}/${toolVersion}/${toolName}-${toolVersion}.zip"
	def response =sh(script:"curl ${url} -o ${toolName}.zip",returnStdout: true).trim()
	unzip dir:"${toolName}", quiet: true, zipFile: "${toolName}.zip"	
	execute("rm -rf ${toolName}.zip")
}

def getGiHubInfo() {
	def githubObj = [
		'ownerName':'',
		'repoName':''
		]
	String[] splitURLString = "${env.GITHUB_URL}".split("/")
	githubObj.repoName = splitURLString[splitURLString.size()-1]
	githubObj.repoName = githubObj.repoName.replace(".git","")
	githubObj.ownerName = splitURLString[splitURLString.size()-2]
	return githubObj
}

def getTopics () {
	def metadata = readJSON file:".main-meta/main.json"	
	List keywords = metadata.content.keywords
	topicsAsString = keywords[0].toString()
	for (int i = 0; i < keywords.size()-1; i++) {
        topicsAsString = topicsAsString + ','+keywords[i+1].toString()
    }
    topicsAsString = topicsAsString.replace("\n", "").replace(" ", "-").replace("\t", "").replace("\r", "")
	return topicsAsString
}
def deployReport(String src) {
	def source = src	
	def files = findFiles glob: "${source}" 
	if( files.length > 0 ) {
		//def repository = 'mcu8-bin/8bit-Example'	
		def repository = 'citd/report'
		def slug = GIT_URL.tokenize('/')[4]
		slug = slug.substring(0, slug.lastIndexOf('.')) //Remove .git
		def sourceZipFile = "${slug}-${env.BRANCH_NAME}.${env.BUILD_NUMBER}.zip"
		def targetZipFile = "${env.ARTIFACTORY_SERVER}/${repository}/${slug}/${env.BRANCH_NAME}/${slug}-${env.BRANCH_NAME}.${env.BUILD_NUMBER}.zip"
		zip archive: false, glob: "${source}",zipFile: "${sourceZipFile}"
		execute("curl -T ${sourceZipFile} ${targetZipFile}")	
		execute("rm -rf ${sourceZipFile}")
		sendReportEmail(targetZipFile)
	}
}

def createEmailList(){
    execute("python3 -m pip install jira")
	//def tool_version = readProperties  file: './mpae-buildpipeline-groovy-scripts/tool.properties'
	download("tool-get-email-address","1.2.1")
	withCredentials([usernamePassword(credentialsId: 'Jira-acess-Credentials', usernameVariable: 'JiraID', passwordVariable:'JiraPassword' )]) {					
		execute("cd tool-get-email-address && python3 emailAddressFromJira.py -id ${JiraID} -tkn ${JiraPassword}")
	}
	env.JIRAEMAIL = readFile('email.txt')
	if(!"${env.CHANGE_AUTHOR_EMAIL}".equalsIgnoreCase("null")) {
		env.EMAILLIST = env.CHANGE_AUTHOR_EMAIL
	}else if (env.JIRAEMAIL?.trim()) {
        env.EMAILLIST = env.JIRAEMAIL
    }else{
		env.EMAILLIST = params.NOTIFICATION_EMAIL
	}
	execute("echo ${env.EMAILLIST}")

}

def sendReportEmail(String reportFile) {
    mail to: "${env.EMAILLIST}",
    subject: "Report: ${currentBuild.fullDisplayName}",
    body: "Report: ${reportFile}"
}

def sendSuccessfulGithubDeploymentEmail() {
    emailext( to: "${env.EMAILLIST}",
    subject: "Successful Github Deployment: ${currentBuild.fullDisplayName}",
    body: "The changes have been successfully deployed to GitHub. ${env.GITHUB_URL}")
}

def sendSuccessfulPortalDeploymentEmail() {
    emailext( to: "${env.EMAILLIST}",
    subject: "Successful Portal Deployment: ${currentBuild.fullDisplayName}",
    body: "The changes have been successfully deployed to Discover Portal.")
}
